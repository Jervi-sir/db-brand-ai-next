This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
components/
  dialogs/
    edit-event-dialog.tsx
    event-details-dialog.tsx
  header/
    calendar-header.tsx
    date-navigator.tsx
    today-button.tsx
  month-view/
    calendar-month-view.tsx
    day-cell.tsx
    event-bullet.tsx
    month-event-badge.tsx
  client-container.tsx
contexts/
  calendar-context.tsx
helpers.ts
layout.tsx
page.tsx
types.ts

================================================================
Files
================================================================

================
File: components/dialogs/edit-event-dialog.tsx
================
// File: components/dialogs/edit-event-dialog.tsx
"use client";

import * as React from "react";
import { format, parseISO } from "date-fns";
import { useForm, Controller } from "react-hook-form";
import { useCalendar } from "../../contexts/calendar-context";
import { IEvent, TEventColor } from "../../types";
import {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogClose,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { MinimalTiptapEditor } from "@/app/(tools)/components/minimal-tiptap";
import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs";

interface IFormData {
  title: string;
  userPrompt: string;
  generatedScript: string;
}

interface IProps {
  children: React.ReactNode;
  event: IEvent;
}

export function EditEventDialog({ children, event }: IProps) {
  const { updateEvent } = useCalendar();
  const [open, setOpen] = React.useState(false);

  const form = useForm<IFormData>({
    defaultValues: {
      title: event.title,
      userPrompt: event.userPrompt || "",
      generatedScript: event.generatedScript || "",
    },
  });

  const onSubmit = async (values: IFormData) => {
    try {
      await updateEvent({
        ...event,
        title: values.title,
        userPrompt: values.userPrompt,
        generatedScript: values.generatedScript,
      });
      setOpen(false);
    } catch (error) {
      console.error(error);
      alert("Failed to update event");
    }
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Edit Event</DialogTitle>
        </DialogHeader>
        <form onSubmit={form.handleSubmit(onSubmit)}>
          <Tabs defaultValue="details" className="w-full">
            <TabsList className="grid w-full grid-cols-2">
              <TabsTrigger value="details">Details</TabsTrigger>
              <TabsTrigger value="description">Generated Script</TabsTrigger>
            </TabsList>

            <TabsContent value="details">
              <div className="grid gap-4 py-4">
                <div className="grid gap-2">
                  <Label htmlFor="title">Title</Label>
                  <Input
                    id="title"
                    {...form.register("title", { required: "Title is required" })}
                    placeholder="Enter a title"
                  />
                  {form.formState.errors.title && (
                    <p className="text-red-500 text-xs">
                      {form.formState.errors.title.message}
                    </p>
                  )}
                </div>
                <div className="grid grid-cols-2 gap-4">
                  <div className="grid gap-2">
                    <Label htmlFor="startDate">Start Date</Label>
                    <Input
                      id="startDate"
                      type="text"
                      disabled
                      value={format(parseISO(event.startDate), "MMM d, yyyy")}
                    />
                  </div>
                  <div className="grid gap-2">
                    <Label htmlFor="endDate">End Date</Label>
                    <Input
                      id="endDate"
                      type="text"
                      disabled
                      value={format(parseISO(event.endDate), "MMM d, yyyy")}
                    />
                  </div>
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="stage">Stage</Label>
                  <Input
                    id="stage"
                    type="text"
                    disabled
                    value={event.stage || "script"}
                  />
                </div>
              </div>
            </TabsContent>
            <TabsContent value="description">
              <div className="grid gap-4 py-4">
                <div className="grid gap-2">
                  <Label htmlFor="generatedScript">Generated Script</Label>
                  <Controller
                    name="generatedScript"
                    control={form.control}
                    rules={{ required: "Generated script is required" }}
                    render={({ field }) => (
                      <MinimalTiptapEditor
                        value={field.value}
                        onChange={field.onChange}
                        className="min-h-[200px] w-full"
                        output="html"
                        editable={true}
                        placeholder="Edit generated script..."
                      />
                    )}
                  />
                  {form.formState.errors.generatedScript && (
                    <p className="text-red-500 text-xs">
                      {form.formState.errors.generatedScript.message}
                    </p>
                  )}
                </div>
              </div>
            </TabsContent>
          </Tabs>

          <DialogFooter className="pt-4">
            <DialogClose asChild>
              <Button variant="outline">Cancel</Button>
            </DialogClose>
            <Button type="submit" onClick={form.handleSubmit(onSubmit)}>
              Save Changes
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

================
File: components/dialogs/event-details-dialog.tsx
================
// File: components/dialogs/event-details-dialog.tsx
"use client";

import { format, parseISO } from "date-fns";
import { Calendar, Clock, Text, CheckCircle } from "lucide-react";
import { EditEventDialog } from "./edit-event-dialog";
import * as React from "react";
import { useCalendar } from "../../contexts/calendar-context";
import { IEvent } from "../../types";
import {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";

interface IProps {
  event: IEvent;
  children: React.ReactNode;
}

export function EventDetailsDialog({ event, children }: IProps) {
  const { deleteEvent } = useCalendar();
  const [open, setOpen] = React.useState(false);
  const startDate = parseISO(event.startDate);
  const endDate = parseISO(event.endDate);

  const handleDelete = async () => {
    if (confirm("Are you sure you want to delete this event?")) {
      try {
        await deleteEvent(event.id);
        setOpen(false);
      } catch (error) {
        console.error(error);
        alert("Failed to delete event");
      }
    }
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>{event.title}</DialogTitle>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          <div className="grid grid-cols-2 gap-4 py-4">
            <div className="flex items-start gap-2">
              <Calendar className="mt-1 size-4" />
              <div>
                <p className="text-sm font-medium">Scheduled Date</p>
                <p className="text-sm text-muted-foreground">
                  {format(startDate, "MMM d, yyyy")}
                </p>
              </div>
            </div>
            <div className="flex items-start gap-2">
              <Clock className="mt-1 size-4" />
              <div>
                <p className="text-sm font-medium">Deadline</p>
                <p className="text-sm text-muted-foreground">
                  {format(endDate, "MMM d, yyyy")}
                </p>
              </div>
            </div>
          </div>
          {event.stage && (
            <div className="flex items-center gap-2">
              <CheckCircle className="mt-1 size-4" />
              <div className="flex gap-2">
                <p className="text-sm font-medium">Stage</p>
                <p className="text-sm text-muted-foreground">
                  {event.stage.charAt(0).toUpperCase() +
                    event.stage.slice(1).replace("_", " ") || "N/A"}
                </p>
              </div>
            </div>
          )}
          {event.title && (
            <div className="flex items-start gap-2">
              <Text className="mt-1 size-4" />
              <div>
                <p className="text-sm font-medium">Title</p>
                <p className="text-sm text-muted-foreground">
                  {event.title}
                </p>
              </div>
            </div>
          )}
          {event.userPrompt && (
            <div className="flex items-start gap-2">
              <Text className="mt-1 size-4" />
              <div>
                <p className="text-sm font-medium">Description</p> {/* Changed from User Prompt */}
                <p className="text-sm text-muted-foreground">
                  {event.userPrompt}
                </p>
              </div>
            </div>
          )}
        </div>
        <DialogFooter>
          <div className="mr-auto space-x-4">
            <Button variant="destructive" onClick={handleDelete}>
              Delete
            </Button>
            <EditEventDialog event={event}>
              <Button variant="outline">Edit</Button>
            </EditEventDialog>
          </div>
          <Button variant="secondary" onClick={() => setOpen(false)}>
            Cancel
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

================
File: components/header/calendar-header.tsx
================
import { DateNavigator } from "./date-navigator";
import { TodayButton } from "./today-button";
import { IEvent } from "../../types";

interface IProps {
  view: "month";
  events: IEvent[];
}

export function CalendarHeader({ view, events }: IProps) {
  return (
    <div className="flex flex-col gap-4 border-b p-4 lg:flex-row lg:items-center lg:justify-between">
      <div className="flex items-center justify-between gap-3 flex-1">
        <TodayButton />
        <DateNavigator view={view} events={events} />
      </div>
    </div>
  );
}

================
File: components/header/date-navigator.tsx
================
import { useMemo } from "react";
import { formatDate } from "date-fns";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { useCalendar } from "../../contexts/calendar-context";
import { getEventsCount, navigateDate, rangeText } from "../../helpers";

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

interface IProps {
  view: "month";
  events: IEvent[];
}

export function DateNavigator({ view, events }: IProps) {
  const { selectedDate, setSelectedDate } = useCalendar();
  const month = formatDate(selectedDate, "MMMM");
  const year = selectedDate.getFullYear();
  const eventCount = useMemo(
    () => getEventsCount(events, selectedDate, view),
    [events, selectedDate, view]
  );

  const handlePrevious = () => setSelectedDate(navigateDate(selectedDate, view, "previous"));
  const handleNext = () => setSelectedDate(navigateDate(selectedDate, view, "next"));

  return (
    <div className="space-y-0.5">
      <div className="flex items-center gap-2">
        <span className="text-lg font-semibold">
          {month} {year}
        </span>
        <span className="border border-gray-300 rounded px-1.5 text-xs">
          {eventCount} events
        </span>
      </div>
      <div className="flex items-center gap-2">
        <button
          className="size-6 border border-gray-300 rounded flex items-center justify-center"
          onClick={handlePrevious}
        >
          <ChevronLeft className="size-4" />
        </button>
        <p className="text-sm text-gray-500">{rangeText(view, selectedDate)}</p>
        <button
          className="size-6 border border-gray-300 rounded flex items-center justify-center"
          onClick={handleNext}
        >
          <ChevronRight className="size-4" />
        </button>
      </div>
    </div>
  );
}

================
File: components/header/today-button.tsx
================
import { formatDate } from "date-fns";
import { useCalendar } from "../../contexts/calendar-context";

export function TodayButton() {
  const { setSelectedDate } = useCalendar();
  const today = new Date();
  const handleClick = () => setSelectedDate(today);

  return (
    <button
      className="flex size-14 flex-col items-start rounded-lg border"
      onClick={handleClick}
    >
      <p className="flex h-6 w-full items-center justify-center bg-blue-600 text-xs font-semibold text-white">
        {formatDate(today, "MMM").toUpperCase()}
      </p>
      <p className="flex w-full items-center justify-center text-lg font-bold">
        {today.getDate()}
      </p>
    </button>
  );
}

================
File: components/month-view/calendar-month-view.tsx
================
import { useMemo } from "react";
import { useCalendar } from "../../contexts/calendar-context";
import { DayCell } from "./day-cell";
import { getCalendarCells, calculateMonthEventPositions } from "../../helpers";

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

interface IProps {
  singleDayEvents: IEvent[];
  multiDayEvents: IEvent[];
}

const WEEK_DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

export function CalendarMonthView({ singleDayEvents, multiDayEvents }: IProps) {
  const { selectedDate } = useCalendar();
  const allEvents = [...multiDayEvents, ...singleDayEvents];
  const cells = useMemo(() => getCalendarCells(selectedDate), [selectedDate]);
  const eventPositions = useMemo(
    () => calculateMonthEventPositions(multiDayEvents, singleDayEvents, selectedDate),
    [multiDayEvents, singleDayEvents, selectedDate]
  );

  return (
    <div>
      <div className="grid grid-cols-7 divide-x">
        {WEEK_DAYS.map((day) => (
          <div key={day} className="flex items-center justify-center py-2">
            <span className="text-xs font-medium text-gray-500">{day}</span>
          </div>
        ))}
      </div>
      <div className="grid grid-cols-7 overflow-hidden">
        {cells.map((cell) => (
          <DayCell
            key={cell.date.toISOString()}
            cell={cell}
            events={allEvents}
            eventPositions={eventPositions}
          />
        ))}
      </div>
    </div>
  );
}

================
File: components/month-view/day-cell.tsx
================
import { useMemo } from "react";
import { isToday, startOfDay } from "date-fns";
import { EventBullet } from "./event-bullet";
import { MonthEventBadge } from "./month-event-badge";
import { getMonthCellEvents } from "../../helpers";

interface ICalendarCell {
  day: number;
  currentMonth: boolean;
  date: Date;
}

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

interface IProps {
  cell: ICalendarCell;
  events: IEvent[];
  eventPositions: Record<string, number>;
}

const MAX_VISIBLE_EVENTS = 3;

export function DayCell({ cell, events, eventPositions }: IProps) {
  const { day, currentMonth, date } = cell;
  const cellEvents = useMemo(
    () => getMonthCellEvents(date, events, eventPositions),
    [date, events, eventPositions]
  );
  const isSunday = date.getDay() === 0;

  return (
    <>
      <div
        className={`flex h-full flex-col gap-1 border-l border-t py-1.5 lg:py-2 ${
          isSunday ? "border-l-0" : ""
        }`}
      >
        <span
          className={`h-6 px-1 text-xs font-semibold lg:px-2 ${
            !currentMonth ? "opacity-20" : ""
          } ${
            isToday(date)
              ? "flex w-6 translate-x-1 items-center justify-center rounded-full bg-blue-600 text-white px-0 font-bold"
              : ""
          }`}
        >
          {day}
        </span>
        <div
          className={`flex h-6 gap-1 px-2 lg:h-[94px] lg:flex-col lg:gap-2 lg:px-0 ${
            !currentMonth ? "opacity-50" : ""
          }`}
        >
          {[0, 1, 2].map((position) => {
            const event = cellEvents.find((e) => e.position === position);
            const eventKey = event
              ? `event-${event.id}-${position}`
              : `empty-${position}`;
            return (
              <div key={eventKey} className="lg:flex-1">
                {event && (
                  <>
                    <EventBullet className="lg:hidden" color={event.color} />
                    <MonthEventBadge
                      className="hidden lg:flex"
                      event={event}
                      cellDate={startOfDay(date)}
                    />
                  </>
                )}
              </div>
            );
          })}
        </div>
        {cellEvents.length > MAX_VISIBLE_EVENTS && (
          <p
            className={`h-4.5 px-1.5 text-xs font-semibold text-gray-500 ${
              !currentMonth ? "opacity-50" : ""
            }`}
          >
            <span className="sm:hidden">
              +{cellEvents.length - MAX_VISIBLE_EVENTS}
            </span>
            <span className="hidden sm:inline">
              {" "}
              {cellEvents.length - MAX_VISIBLE_EVENTS} more...
            </span>
          </p>
        )}
      </div>
    </>
  );
}

================
File: components/month-view/event-bullet.tsx
================
interface IProps {
  color: string;
  className?: string;
}

export function EventBullet({ color, className }: IProps) {
  const colorClasses: Record<string, string> = {
    blue: "bg-blue-600",
    green: "bg-green-600",
    red: "bg-red-600",
    yellow: "bg-yellow-600",
    purple: "bg-purple-600",
    orange: "bg-orange-600",
    gray: "bg-gray-600",
  };
  return (
    <div
      className={`size-2 rounded-full ${colorClasses[color] || "bg-blue-600"} ${
        className || ""
      }`}
    />
  );
}

================
File: components/month-view/month-event-badge.tsx
================
import { format, isSameDay, parseISO, startOfDay, endOfDay } from "date-fns";
import { EventDetailsDialog } from "../dialogs/event-details-dialog";

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

interface IProps {
  event: IEvent;
  cellDate: Date;
  className?: string;
  position?: "first" | "middle" | "last" | "none";
}

export function MonthEventBadge({
  event,
  cellDate,
  className,
  position: propPosition,
}: IProps) {
  const itemStart = startOfDay(parseISO(event.startDate));
  const itemEnd = endOfDay(parseISO(event.endDate));

  if (cellDate < itemStart || cellDate > itemEnd) return null;

  const position =
    propPosition ||
    (isSameDay(itemStart, itemEnd)
      ? "none"
      : isSameDay(cellDate, itemStart)
      ? "first"
      : isSameDay(cellDate, itemEnd)
      ? "last"
      : "middle");

  const colorClasses: Record<string, string> = {
    blue: "border-blue-200 bg-blue-50 text-blue-700",
    green: "border-green-200 bg-green-50 text-green-700",
    red: "border-red-200 bg-red-50 text-red-700",
    yellow: "border-yellow-200 bg-yellow-50 text-yellow-700",
    purple: "border-purple-200 bg-purple-50 text-purple-700",
    orange: "border-orange-200 bg-orange-50 text-orange-700",
    gray: "border-gray-200 bg-gray-50 text-gray-900",
  };

  const positionClasses: Record<string, string> = {
    first:
      "relative z-10 mr-0 w-[calc(100%_-_3px)] rounded-r-none border-r-0",
    middle: "relative z-10 mx-0 w-[calc(100%_+_1px)] rounded-none border-x-0",
    last: "ml-0 rounded-l-none border-l-0",
    none: "",
  };

  const eventBadgeClasses = `mx-1 flex h-6.5 items-center justify-between gap-1.5 truncate whitespace-nowrap rounded-md border px-2 text-xs ${
    colorClasses[event.color] || "border-blue-200 bg-blue-50 text-blue-700"
  } ${positionClasses[position] || ""} ${className || ""}`;

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      if (e.currentTarget instanceof HTMLElement) e.currentTarget.click();
    }
  };

  const renderBadgeText = ["first", "none"].includes(position);

  return (
    <>
      <EventDetailsDialog event={event as any}>
        <div
          role="button"
          tabIndex={0}
          className={eventBadgeClasses}
          onKeyDown={handleKeyDown}
        >
          <div className="flex items-center gap-1.5 truncate">
            {renderBadgeText && (
              <p className="flex-1 truncate font-semibold">{event.title}</p>
            )}
          </div>
          {renderBadgeText && (
            <span>{format(new Date(event.startDate), "h:mm a")}</span>
          )}
        </div>
      </EventDetailsDialog>
    </>
  );
}

================
File: components/client-container.tsx
================
// File: components/client-container.tsx
"use client";

import { useMemo } from "react";
import { isSameDay, parseISO } from "date-fns";
import { useCalendar } from "../contexts/calendar-context";
import { CalendarHeader } from "./header/calendar-header";
import { CalendarMonthView } from "./month-view/calendar-month-view";

export function ClientContainer() {
  const { events } = useCalendar();
  const filteredEvents = useMemo(() => events || [], [events]);
  const singleDayEvents = filteredEvents.filter((event) => {
    // Skip events with invalid startDate or endDate
    if (!event.startDate || !event.endDate) return false;
    try {
      const startDate = parseISO(event.startDate);
      const endDate = parseISO(event.endDate);
      return isSameDay(startDate, endDate);
    } catch (error) {
      console.error("Invalid date format for event:", event);
      return false;
    }
  });
  const multiDayEvents = filteredEvents.filter((event) => {
    // Skip events with invalid startDate or endDate
    if (!event.startDate || !event.endDate) return false;
    try {
      const startDate = parseISO(event.startDate);
      const endDate = parseISO(event.endDate);
      return !isSameDay(startDate, endDate);
    } catch (error) {
      console.error("Invalid date format for event:", event);
      return false;
    }
  });

  return (
    <div className="rounded-xl border overflow-hidden">
      <CalendarHeader view="month" events={filteredEvents} />
      <>
        <CalendarMonthView
          singleDayEvents={singleDayEvents}
          multiDayEvents={multiDayEvents}
        />
      </>
    </div>
  );
}

================
File: contexts/calendar-context.tsx
================
// File: contexts/calendar-context.tsx
"use client";

import { createContext, useContext, useState } from "react";
import { IEvent } from "../types";

interface ICalendarContext {
  selectedDate: Date;
  setSelectedDate: (date: Date) => void;
  events: IEvent[];
  setEvents: (events: IEvent[]) => void;
  addEvent: (event: IEvent) => Promise<void>;
  updateEvent: (event: IEvent) => Promise<void>;
  deleteEvent: (id: string) => Promise<void>;
  enableDnd: boolean;
}

const CalendarContext = createContext<ICalendarContext | undefined>(undefined);

export function CalendarProvider({
  children,
  events: initialEvents,
  enableDnd = false,
}: {
  children: React.ReactNode;
  events: IEvent[];
  enableDnd?: boolean;
}) {
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [events, setEvents] = useState<IEvent[]>(initialEvents);

  const addEvent = async (event: IEvent) => {
    const response = await fetch('/api/calendar/content', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId: event.userId,
        title: event.title,
        userPrompt: event.userPrompt,
        color: event.color,
        generatedScript: event.generatedScript || "",
        stage: event.stage || "script",
        startDate: event.startDate,
        endDate: event.endDate,
      }),
    });
    if (response.ok) {
      const newEvent = await response.json();
      setEvents((prev) => [...prev, newEvent]);
    } else {
      throw new Error('Failed to add event');
    }
  };

  const updateEvent = async (event: IEvent) => {
    const response = await fetch(`/api/calendar/content/${event.id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        id: event.id,
        title: event.title,
        userPrompt: event.userPrompt,
        generatedScript: event.generatedScript,
      }),
    });
    if (response.ok) {
      const updatedEvent = await response.json();
      setEvents((prev) =>
        prev.map((e) => (e.id === event.id ? updatedEvent : e))
      );
    } else {
      throw new Error('Failed to update event');
    }
  };

  const deleteEvent = async (id: string) => {
    const response = await fetch(`/api/calendar/content/${id}`, {
      method: 'DELETE',
    });
    if (response.ok) {
      setEvents((prev) => prev.filter((e) => e.id !== id));
    } else {
      throw new Error('Failed to delete event');
    }
  };

  return (
    <CalendarContext.Provider
      value={{
        selectedDate,
        setSelectedDate,
        events,
        setEvents,
        addEvent,
        updateEvent,
        deleteEvent,
        enableDnd,
      }}
    >
      {children}
    </CalendarContext.Provider>
  );
}

export function useCalendar(): ICalendarContext {
  const context = useContext(CalendarContext);
  if (!context) throw new Error("useCalendar must be used within a CalendarProvider.");
  return context;
}

================
File: helpers.ts
================
import {
  startOfMonth,
  endOfMonth,
  format,
  parseISO,
  differenceInDays,
  eachDayOfInterval,
  startOfDay,
  isSameDay,
  isSameMonth,
  addMonths,
  subMonths,
} from "date-fns";

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

interface ICalendarCell {
  day: number;
  currentMonth: boolean;
  date: Date;
}

export function rangeText(view: "month", date: Date) {
  const start = startOfMonth(date);
  const end = endOfMonth(date);
  return `${format(start, "MMM d, yyyy")} - ${format(end, "MMM d, yyyy")}`;
}

export function navigateDate(date: Date, view: "month", direction: "previous" | "next"): Date {
  return direction === "next" ? addMonths(date, 1) : subMonths(date, 1);
}

export function getEventsCount(events: IEvent[], date: Date, view: "month"): number {
  return events.filter((event) => isSameMonth(new Date(event.startDate), date)).length;
}

export function getCalendarCells(selectedDate: Date): ICalendarCell[] {
  const currentYear = selectedDate.getFullYear();
  const currentMonth = selectedDate.getMonth();
  const getDaysInMonth = (year: number, month: number) =>
    new Date(year, month + 1, 0).getDate();
  const getFirstDayOfMonth = (year: number, month: number) =>
    new Date(year, month, 1).getDay();
  const daysInMonth = getDaysInMonth(currentYear, currentMonth);
  const firstDayOfMonth = getFirstDayOfMonth(currentYear, currentMonth);
  const daysInPrevMonth = getDaysInMonth(currentYear, currentMonth - 1);
  const totalDays = firstDayOfMonth + daysInMonth;

  const prevMonthCells = Array.from({ length: firstDayOfMonth }, (_, i) => ({
    day: daysInPrevMonth - firstDayOfMonth + i + 1,
    currentMonth: false,
    date: new Date(
      currentYear,
      currentMonth - 1,
      daysInPrevMonth - firstDayOfMonth + i + 1
    ),
  }));
  const currentMonthCells = Array.from({ length: daysInMonth }, (_, i) => ({
    day: i + 1,
    currentMonth: true,
    date: new Date(currentYear, currentMonth, i + 1),
  }));
  const nextMonthCells = Array.from(
    { length: (7 - (totalDays % 7)) % 7 },
    (_, i) => ({
      day: i + 1,
      currentMonth: false,
      date: new Date(currentYear, currentMonth + 1, i + 1),
    })
  );

  return [...prevMonthCells, ...currentMonthCells, ...nextMonthCells];
}

export function calculateMonthEventPositions(
  multiDayEvents: IEvent[],
  singleDayEvents: IEvent[],
  selectedDate: Date
) {
  const monthStart = startOfMonth(selectedDate);
  const monthEnd = endOfMonth(selectedDate);
  const eventPositions: { [key: string]: number } = {};
  const occupiedPositions: { [key: string]: boolean[] } = {};

  eachDayOfInterval({ start: monthStart, end: monthEnd }).forEach((day) => {
    occupiedPositions[day.toISOString()] = [false, false, false];
  });

  const sortedEvents = [
    ...multiDayEvents.sort((a, b) => {
      const aDuration = differenceInDays(
        parseISO(a.endDate),
        parseISO(a.startDate)
      );
      const bDuration = differenceInDays(
        parseISO(b.endDate),
        parseISO(b.startDate)
      );
      return (
        bDuration - aDuration ||
        parseISO(a.startDate).getTime() - parseISO(b.startDate).getTime()
      );
    }),
    ...singleDayEvents.sort((a, b) =>
      parseISO(a.startDate).getTime() - parseISO(b.startDate).getTime()
    ),
  ];

  sortedEvents.forEach((event) => {
    const eventStart = parseISO(event.startDate);
    const eventEnd = parseISO(event.endDate);
    const eventDays = eachDayOfInterval({
      start: eventStart < monthStart ? monthStart : eventStart,
      end: eventEnd > monthEnd ? monthEnd : eventEnd,
    });

    let position = -1;
    for (let i = 0; i < 3; i++) {
      if (
        eventDays.every((day) => {
          const dayPositions = occupiedPositions[startOfDay(day).toISOString()];
          return dayPositions && !dayPositions[i];
        })
      ) {
        position = i;
        break;
      }
    }

    if (position !== -1) {
      eventDays.forEach((day) => {
        const dayKey = startOfDay(day).toISOString();
        occupiedPositions[dayKey][position] = true;
      });
      eventPositions[event.id] = position;
    }
  });

  return eventPositions;
}

export function getMonthCellEvents(
  date: Date,
  events: IEvent[],
  eventPositions: Record<string, number>
) {
  const eventsForDate = events.filter((event) => {
    const eventStart = parseISO(event.startDate);
    const eventEnd = parseISO(event.endDate);
    return (
      (date >= eventStart && date <= eventEnd) ||
      isSameDay(date, eventStart) ||
      isSameDay(date, eventEnd)
    );
  });

  return eventsForDate
    .map((event) => ({
      ...event,
      position: eventPositions[event.id] ?? -1,
      isMultiDay: event.startDate !== event.endDate,
    }))
    .sort((a, b) => {
      if (a.isMultiDay && !b.isMultiDay) return -1;
      if (!a.isMultiDay && b.isMultiDay) return 1;
      return a.position - b.position;
    });
}

export const stripHtml = (html: string): string => {
  const tmp = document.createElement('div');
  tmp.innerHTML = html;
  return tmp.textContent || tmp.innerText || '';
};

================
File: layout.tsx
================
import { CalendarProvider } from "./contexts/calendar-context";
import { SessionProvider } from "next-auth/react";
import { SidebarInset, SidebarProvider, SidebarTrigger } from "@/components/ui/sidebar";
import { AppSidebar } from "@/components/app-sidebar";
import Script from "next/script";
import { auth } from "@/app/(auth)/auth";
import { cookies } from "next/headers";
import { Separator } from "@/components/ui/separator";

export default async function Layout({ children }: { children: React.ReactNode }) {
  const [session, cookieStore] = await Promise.all([auth(), cookies()]);
  const isCollapsed = cookieStore.get('sidebar:state')?.value !== 'true';

  return (
    <SessionProvider session={session}>
      <Script
        src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"
        strategy="beforeInteractive"
      />
      <SidebarProvider defaultOpen={!isCollapsed}>
        <AppSidebar user={session?.user} />
        <SidebarInset>
          <>
            <header className="flex h-16 shrink-0 items-center gap-2 border-b pr-10">
              <div className="flex items-center gap-2 px-3">
                <SidebarTrigger />
                <Separator orientation="vertical" className="mr-2 h-4" />
                <h4>Schedule</h4>
              </div>
            </header>
            <div className="flex flex-col gap-4 px-8 py-4">
              {children}
            </div>
          </>
        </SidebarInset>
      </SidebarProvider>
    </SessionProvider>
  );
}

================
File: page.tsx
================
// File: page.tsx
import { ClientContainer } from "./components/client-container";
import { CalendarProvider } from "./contexts/calendar-context";
import { TEventColor } from "./types";

async function fetchEvents() {
  const baseUrl = process.env.NEXT_PUBLIC_BASE_URL || "http://localhost:3000";
  const response = await fetch(`${baseUrl}/api/calendar/content`, {
    cache: "no-store",
  });
  if (!response.ok) return [];
  const events = await response.json();
  const defaultDate = new Date().toISOString();
  return events.map((event: any) => ({
    id: event.id,
    userId: event.userId,
    title: event.title,
    userPrompt: event.userPrompt,
    startDate: event.scheduledDate ? new Date(event.scheduledDate).toISOString() : defaultDate,
    endDate: event.deadline ? new Date(event.deadline).toISOString() : defaultDate,
    color: (event.mood || "blue") as TEventColor,
    stage: event.stage,
    generatedScript: event.generatedScript,
  }));
}

export default async function Page() {
  const events = await fetchEvents();
  return (
    <CalendarProvider events={events} enableDnd={false}>
      <ClientContainer />
    </CalendarProvider>
  );
}

================
File: types.ts
================
// File: types.ts
export type TCalendarView = "month";
export type TEventColor =
  | "blue"
  | "green"
  | "red"
  | "yellow"
  | "purple"
  | "orange"
  | "gray";

export interface IEvent {
  id: string;
  userId?: string; // Changed from user_id to match database
  title: string;
  userPrompt: string;
  color: TEventColor; // Use TEventColor for type safety
  generatedScript: string;
  stage: string;
  startDate: string; // Changed from scheduledDate for consistency
  endDate: string; // Changed from deadline for consistency
}



================================================================
End of Codebase
================================================================

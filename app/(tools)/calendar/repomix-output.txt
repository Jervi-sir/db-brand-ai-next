This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
components/
  dialogs/
    add-event-dialog.tsx
    edit-event-dialog.tsx
    event-details-dialog.tsx
  dnd/
    dnd-provider.tsx
    draggable-event.tsx
    droppable-day-cell.tsx
  header/
    calendar-header.tsx
    date-navigator.tsx
    today-button.tsx
  month-view/
    calendar-month-view.tsx
    day-cell.tsx
    event-bullet.tsx
    month-event-badge.tsx
  client-container.tsx
contexts/
  calendar-context.tsx
helpers.ts
layout.tsx
page.tsx
types.ts

================================================================
Files
================================================================

================
File: components/dialogs/add-event-dialog.tsx
================
"use client";

import { useState } from "react";
import { useForm } from "react-hook-form";
import { useCalendar } from "../../contexts/calendar-context";

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

interface IFormData {
  user?: string;
  title: string;
  description: string;
  startDate: Date;
  startTime: string; // e.g., "09:00"
  endDate: Date;
  endTime: string; // e.g., "10:00"
  color: string;
}

interface IProps {
  children: React.ReactNode;
  startDate?: Date;
  startTime?: { hour: number; minute: number };
}

export function AddEventDialog({ children, startDate, startTime }: IProps) {
  const { users, addEvent } = useCalendar();
  const [isOpen, setIsOpen] = useState(false);

  const form = useForm<IFormData>({
    defaultValues: {
      title: "",
      description: "",
      startDate: startDate || new Date(),
      startTime: startTime
        ? `${startTime.hour.toString().padStart(2, "0")}:${startTime.minute
            .toString()
            .padStart(2, "0")}`
        : "09:00",
      endDate: startDate || new Date(),
      endTime: "10:00",
      color: "blue",
    },
  });

  const onSubmit = (values: IFormData) => {
    const [startHour, startMinute] = values.startTime.split(":").map(Number);
    const [endHour, endMinute] = values.endTime.split(":").map(Number);

    const startDateTime = new Date(values.startDate);
    startDateTime.setHours(startHour, startMinute);

    const endDateTime = new Date(values.endDate);
    endDateTime.setHours(endHour, endMinute);

    const user = values.user
      ? users.find((u) => u.id === values.user)
      : undefined;

    addEvent({
      id: Date.now(), // Temporary ID; replace with API-generated ID
      title: values.title,
      description: values.description,
      startDate: startDateTime.toISOString(),
      endDate: endDateTime.toISOString(),
      color: values.color,
      user,
    });

    setIsOpen(false);
    form.reset();
  };

  return (
    <>
      <div onClick={() => setIsOpen(true)}>{children}</div>
      <div className={`fixed inset-0 ${isOpen ? "block" : "hidden"} bg-black/50 z-50`}>
        <div className="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-white p-6 rounded-lg max-w-md w-full">
          <h2 className="text-lg font-semibold mb-4">Add New Event</h2>
          <form onSubmit={form.handleSubmit(onSubmit)} className="grid gap-4">
            {users.length > 0 && (
              <div>
                <label className="block text-sm font-medium text-gray-700">
                  Responsible
                </label>
                <select
                  {...form.register("user")}
                  className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
                >
                  <option value="">Select a user</option>
                  {users.map((user) => (
                    <option key={user.id} value={user.id}>
                      {user.name}
                    </option>
                  ))}
                </select>
              </div>
            )}
            <div>
              <label className="block text-sm font-medium text-gray-700">
                Title
              </label>
              <input
                {...form.register("title", { required: "Title is required" })}
                className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
                placeholder="Enter a title"
              />
              {form.formState.errors.title && (
                <p className="text-red-500 text-xs mt-1">
                  {form.formState.errors.title.message}
                </p>
              )}
            </div>
            <div className="flex gap-2">
              <div className="flex-1">
                <label className="block text-sm font-medium text-gray-700">
                  Start Date
                </label>
                <input
                  type="date"
                  {...form.register("startDate", {
                    required: "Start date is required",
                    valueAsDate: true,
                  })}
                  className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
                />
                {form.formState.errors.startDate && (
                  <p className="text-red-500 text-xs mt-1">
                    {form.formState.errors.startDate.message}
                  </p>
                )}
              </div>
              <div className="flex-1">
                <label className="block text-sm font-medium text-gray-700">
                  Start Time
                </label>
                <input
                  type="time"
                  {...form.register("startTime", {
                    required: "Start time is required",
                  })}
                  className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
                />
                {form.formState.errors.startTime && (
                  <p className="text-red-500 text-xs mt-1">
                    {form.formState.errors.startTime.message}
                  </p>
                )}
              </div>
            </div>
            <div className="flex gap-2">
              <div className="flex-1">
                <label className="block text-sm font-medium text-gray-700">
                  End Date
                </label>
                <input
                  type="date"
                  {...form.register("endDate", {
                    required: "End date is required",
                    valueAsDate: true,
                  })}
                  className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
                />
                {form.formState.errors.endDate && (
                  <p className="text-red-500 text-xs mt-1">
                    {form.formState.errors.endDate.message}
                  </p>
                )}
              </div>
              <div className="flex-1">
                <label className="block text-sm font-medium text-gray-700">
                  End Time
                </label>
                <input
                  type="time"
                  {...form.register("endTime", {
                    required: "End time is required",
                  })}
                  className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
                />
                {form.formState.errors.endTime && (
                  <p className="text-red-500 text-xs mt-1">
                    {form.formState.errors.endTime.message}
                  </p>
                )}
              </div>
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700">
                Color
              </label>
              <select
                {...form.register("color", { required: "Color is required" })}
                className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
              >
                {[
                  "blue",
                  "green",
                  "red",
                  "yellow",
                  "purple",
                  "orange",
                  "gray",
                ].map((color) => (
                  <option key={color} value={color}>
                    {color.charAt(0).toUpperCase() + color.slice(1)}
                  </option>
                ))}
              </select>
              {form.formState.errors.color && (
                <p className="text-red-500 text-xs mt-1">
                  {form.formState.errors.color.message}
                </p>
              )}
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700">
                Description
              </label>
              <textarea
                {...form.register("description", {
                  required: "Description is required",
                })}
                className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
                rows={4}
                placeholder="Enter a description"
              />
              {form.formState.errors.description && (
                <p className="text-red-500 text-xs mt-1">
                  {form.formState.errors.description.message}
                </p>
              )}
            </div>
            <div className="flex justify-end gap-2">
              <button
                type="button"
                onClick={() => setIsOpen(false)}
                className="border border-gray-300 rounded px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
              >
                Cancel
              </button>
              <button
                type="submit"
                className="bg-blue-600 text-white rounded px-4 py-2 text-sm hover:bg-blue-700"
              >
                Create Event
              </button>
            </div>
          </form>
        </div>
      </div>
    </>
  );
}

================
File: components/dialogs/edit-event-dialog.tsx
================
"use client";

import { useState } from "react";
import { parseISO } from "date-fns";
import { useForm } from "react-hook-form";
import { useCalendar } from "../../contexts/calendar-context";

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

interface IFormData {
  user?: string;
  title: string;
  description: string;
  startDate: Date;
  startTime: string; // e.g., "09:00"
  endDate: Date;
  endTime: string; // e.g., "10:00"
  color: string;
}

interface IProps {
  children: React.ReactNode;
  event: IEvent;
}

export function EditEventDialog({ children, event }: IProps) {
  const { users, updateEvent } = useCalendar();
  const [isOpen, setIsOpen] = useState(false);

  const form = useForm<IFormData>({
    defaultValues: {
      user: event.user?.id,
      title: event.title,
      description: event.description || "",
      startDate: parseISO(event.startDate),
      startTime: `${parseISO(event.startDate)
        .getHours()
        .toString()
        .padStart(2, "0")}:${parseISO(event.startDate)
        .getMinutes()
        .toString()
        .padStart(2, "0")}`,
      endDate: parseISO(event.endDate),
      endTime: `${parseISO(event.endDate)
        .getHours()
        .toString()
        .padStart(2, "0")}:${parseISO(event.endDate)
        .getMinutes()
        .toString()
        .padStart(2, "0")}`,
      color: event.color,
    },
  });

  const onSubmit = (values: IFormData) => {
    const [startHour, startMinute] = values.startTime.split(":").map(Number);
    const [endHour, endMinute] = values.endTime.split(":").map(Number);

    const startDateTime = new Date(values.startDate);
    startDateTime.setHours(startHour, startMinute);

    const endDateTime = new Date(values.endDate);
    endDateTime.setHours(endHour, endMinute);

    const user = values.user
      ? users.find((u) => u.id === values.user)
      : event.user;

    updateEvent({
      ...event,
      title: values.title,
      description: values.description,
      startDate: startDateTime.toISOString(),
      endDate: endDateTime.toISOString(),
      color: values.color,
      user,
    });

    setIsOpen(false);
  };

  return (
    <>
      <div onClick={() => setIsOpen(true)}>{children}</div>
      <div className={`fixed inset-0 ${isOpen ? "block" : "hidden"} bg-black/50 z-50`}>
        <div className="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-white p-6 rounded-lg max-w-md w-full">
          <h2 className="text-lg font-semibold mb-4">Edit Event</h2>
          <form onSubmit={form.handleSubmit(onSubmit)} className="grid gap-4">
            {users.length > 0 && (
              <div>
                <label className="block text-sm font-medium text-gray-700">
                  Responsible
                </label>
                <select
                  {...form.register("user")}
                  className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
                >
                  <option value="">Select a user</option>
                  {users.map((user) => (
                    <option key={user.id} value={user.id}>
                      {user.name}
                    </option>
                  ))}
                </select>
              </div>
            )}
            <div>
              <label className="block text-sm font-medium text-gray-700">
                Title
              </label>
              <input
                {...form.register("title", { required: "Title is required" })}
                className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
                placeholder="Enter a title"
              />
              {form.formState.errors.title && (
                <p className="text-red-500 text-xs mt-1">
                  {form.formState.errors.title.message}
                </p>
              )}
            </div>
            <div className="flex gap-2">
              <div className="flex-1">
                <label className="block text-sm font-medium text-gray-700">
                  Start Date
                </label>
                <input
                  type="date"
                  {...form.register("startDate", {
                    required: "Start date is required",
                    valueAsDate: true,
                  })}
                  className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
                />
                {form.formState.errors.startDate && (
                  <p className="text-red-500 text-xs mt-1">
                    {form.formState.errors.startDate.message}
                  </p>
                )}
              </div>
              <div className="flex-1">
                <label className="block text-sm font-medium text-gray-700">
                  Start Time
                </label>
                <input
                  type="time"
                  {...form.register("startTime", {
                    required: "Start time is required",
                  })}
                  className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
                />
                {form.formState.errors.startTime && (
                  <p className="text-red-500 text-xs mt-1">
                    {form.formState.errors.startTime.message}
                  </p>
                )}
              </div>
            </div>
            <div className="flex gap-2">
              <div className="flex-1">
                <label className="block text-sm font-medium text-gray-700">
                  End Date
                </label>
                <input
                  type="date"
                  {...form.register("endDate", {
                    required: "End date is required",
                    valueAsDate: true,
                  })}
                  className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
                />
                {form.formState.errors.endDate && (
                  <p className="text-red-500 text-xs mt-1">
                    {form.formState.errors.endDate.message}
                  </p>
                )}
              </div>
              <div className="flex-1">
                <label className="block text-sm font-medium text-gray-700">
                  End Time
                </label>
                <input
                  type="time"
                  {...form.register("endTime", {
                    required: "End time is required",
                  })}
                  className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
                />
                {form.formState.errors.endTime && (
                  <p className="text-red-500 text-xs mt-1">
                    {form.formState.errors.endTime.message}
                  </p>
                )}
              </div>
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700">
                Color
              </label>
              <select
                {...form.register("color", { required: "Color is required" })}
                className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
              >
                {[
                  "blue",
                  "green",
                  "red",
                  "yellow",
                  "purple",
                  "orange",
                  "gray",
                ].map((color) => (
                  <option key={color} value={color}>
                    {color.charAt(0).toUpperCase() + color.slice(1)}
                  </option>
                ))}
              </select>
              {form.formState.errors.color && (
                <p className="text-red-500 text-xs mt-1">
                  {form.formState.errors.color.message}
                </p>
              )}
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-700">
                Description
              </label>
              <textarea
                {...form.register("description", {
                  required: "Description is required",
                })}
                className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
                rows={4}
                placeholder="Enter a description"
              />
              {form.formState.errors.description && (
                <p className="text-red-500 text-xs mt-1">
                  {form.formState.errors.description.message}
                </p>
              )}
            </div>
            <div className="flex justify-end gap-2">
              <button
                type="button"
                onClick={() => setIsOpen(false)}
                className="border border-gray-300 rounded px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
              >
                Cancel
              </button>
              <button
                type="submit"
                className="bg-blue-600 text-white rounded px-4 py-2 text-sm hover:bg-blue-700"
              >
                Save Changes
              </button>
            </div>
          </form>
        </div>
      </div>
    </>
  );
}

================
File: components/dialogs/event-details-dialog.tsx
================
"use client";

import { format, parseISO } from "date-fns";
import { Calendar, Clock, Text, User } from "lucide-react";
import { EditEventDialog } from "./edit-event-dialog";
import { useState } from "react";

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

interface IProps {
  event: IEvent;
  children: React.ReactNode;
}

export function EventDetailsDialog({ event, children }: IProps) {
  const [isOpen, setIsOpen] = useState(false);
  const startDate = parseISO(event.startDate);
  const endDate = parseISO(event.endDate);

  return (
    <div className={`fixed inset-0 ${isOpen ? "block" : "hidden"} bg-black/50`}>
      <div className="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-white p-6 rounded-lg max-w-md w-full">
        <h2 className="text-lg font-semibold">{event.title}</h2>
        <div className="space-y-4 mt-4">
          {event.user && (
            <div className="flex items-start gap-2">
              <User className="mt-1 size-4" />
              <div>
                <p className="text-sm font-medium">Responsible</p>
                <p className="text-sm text-gray-500">{event.user.name}</p>
              </div>
            </div>
          )}
          <div className="flex items-start gap-2">
            <Calendar className="mt-1 size-4" />
            <div>
              <p className="text-sm font-medium">Start Date</p>
              <p className="text-sm text-gray-500">
                {format(startDate, "MMM d, yyyy h:mm a")}
              </p>
            </div>
          </div>
          <div className="flex items-start gap-2">
            <Clock className="mt-1 size-4" />
            <div>
              <p className="text-sm font-medium">End Date</p>
              <p className="text-sm text-gray-500">
                {format(endDate, "MMM d, yyyy h:mm a")}
              </p>
            </div>
          </div>
          {event.description && (
            <div className="flex items-start gap-2">
              <Text className="mt-1 size-4" />
              <div>
                <p className="text-sm font-medium">Description</p>
                <p className="text-sm text-gray-500">{event.description}</p>
              </div>
            </div>
          )}
        </div>
        <div className="flex justify-end mt-4">
          <EditEventDialog event={event}>
            <button className="border rounded px-4 py-2">Edit</button>
          </EditEventDialog>
        </div>
      </div>
      <div onClick={() => setIsOpen(true)}>{children}</div>
    </div>
  );
}

================
File: components/dnd/dnd-provider.tsx
================
"use client";

import { DndProvider } from "react-dnd";
import { HTML5Backend } from "react-dnd-html5-backend";

interface IProps {
  children: React.ReactNode;
}

export function DndProviderWrapper({ children }: IProps) {
  return <DndProvider backend={HTML5Backend}>{children}</DndProvider>;
}

================
File: components/dnd/draggable-event.tsx
================
"use client";

import { useRef } from "react";
import { useDrag } from "react-dnd";

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

export const ItemTypes = {
  EVENT: "event",
};

interface IProps {
  event: IEvent;
  children: React.ReactNode;
}

export function DraggableEvent({ event, children }: IProps) {
  const ref = useRef<HTMLDivElement>(null);
  const [{ isDragging }, drag] = useDrag(() => ({
    type: ItemTypes.EVENT,
    item: { event },
    collect: (monitor) => ({ isDragging: monitor.isDragging() }),
  }));
  drag(ref);

  return (
    <div ref={ref} className={isDragging ? "opacity-40" : ""}>
      {children}
    </div>
  );
}

================
File: components/dnd/droppable-day-cell.tsx
================
"use client";

import { useDrop } from "react-dnd";
import { parseISO, differenceInMilliseconds } from "date-fns";
import { useCalendar } from "../../contexts/calendar-context";
import { ItemTypes } from "./draggable-event";

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

interface ICalendarCell {
  day: number;
  currentMonth: boolean;
  date: Date;
}

interface IProps {
  cell: ICalendarCell;
  children: React.ReactNode;
}

export function DroppableDayCell({ cell, children }: IProps) {
  const { updateEvent } = useCalendar();
  const [{ isOver, canDrop }, drop] = useDrop(
    () => ({
      accept: ItemTypes.EVENT,
      drop: (item: { event: IEvent }) => {
        const droppedEvent = item.event;
        const eventStartDate = parseISO(droppedEvent.startDate);
        const eventEndDate = parseISO(droppedEvent.endDate);
        const eventDurationMs = differenceInMilliseconds(
          eventEndDate,
          eventStartDate
        );
        const newStartDate = new Date(cell.date);
        newStartDate.setHours(
          eventStartDate.getHours(),
          eventStartDate.getMinutes(),
          eventStartDate.getSeconds(),
          eventStartDate.getMilliseconds()
        );
        const newEndDate = new Date(newStartDate.getTime() + eventDurationMs);
        updateEvent({
          ...droppedEvent,
          startDate: newStartDate.toISOString(),
          endDate: newEndDate.toISOString(),
        });
        return { moved: true };
      },
      collect: (monitor) => ({
        isOver: monitor.isOver(),
        canDrop: monitor.canDrop(),
      }),
    }),
    [cell.date, updateEvent]
  );

  return (
    <div
      ref={drop as unknown as React.RefObject<HTMLDivElement>}
      className={isOver && canDrop ? "bg-gray-100" : ""}
    >
      {children}
    </div>
  );
}

================
File: components/header/calendar-header.tsx
================
import { Plus } from "lucide-react";
import { AddEventDialog } from "../dialogs/add-event-dialog";
import { DateNavigator } from "./date-navigator";
import { TodayButton } from "./today-button";

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

interface IProps {
  view: "month";
  events: IEvent[];
}

export function CalendarHeader({ view, events }: IProps) {
  return (
    <div className="flex flex-col gap-4 border-b p-4 lg:flex-row lg:items-center lg:justify-between">
      <div className="flex items-center justify-between gap-3 flex-1">
        <TodayButton />
        <DateNavigator view={view} events={events} />
      </div>
      <AddEventDialog>
        <button className="flex items-center gap-2 bg-blue-600 text-white px-4 py-2 rounded-md">
          <Plus />
          Add Event
        </button>
      </AddEventDialog>
    </div>
  );
}

================
File: components/header/date-navigator.tsx
================
import { useMemo } from "react";
import { formatDate } from "date-fns";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { useCalendar } from "../../contexts/calendar-context";
import { getEventsCount, navigateDate, rangeText } from "../../helpers";

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

interface IProps {
  view: "month";
  events: IEvent[];
}

export function DateNavigator({ view, events }: IProps) {
  const { selectedDate, setSelectedDate } = useCalendar();
  const month = formatDate(selectedDate, "MMMM");
  const year = selectedDate.getFullYear();
  const eventCount = useMemo(
    () => getEventsCount(events, selectedDate, view),
    [events, selectedDate, view]
  );

  const handlePrevious = () => setSelectedDate(navigateDate(selectedDate, view, "previous"));
  const handleNext = () => setSelectedDate(navigateDate(selectedDate, view, "next"));

  return (
    <div className="space-y-0.5">
      <div className="flex items-center gap-2">
        <span className="text-lg font-semibold">
          {month} {year}
        </span>
        <span className="border border-gray-300 rounded px-1.5 text-xs">
          {eventCount} events
        </span>
      </div>
      <div className="flex items-center gap-2">
        <button
          className="size-6 border border-gray-300 rounded flex items-center justify-center"
          onClick={handlePrevious}
        >
          <ChevronLeft className="size-4" />
        </button>
        <p className="text-sm text-gray-500">{rangeText(view, selectedDate)}</p>
        <button
          className="size-6 border border-gray-300 rounded flex items-center justify-center"
          onClick={handleNext}
        >
          <ChevronRight className="size-4" />
        </button>
      </div>
    </div>
  );
}

================
File: components/header/today-button.tsx
================
import { formatDate } from "date-fns";
import { useCalendar } from "../../contexts/calendar-context";

export function TodayButton() {
  const { setSelectedDate } = useCalendar();
  const today = new Date();
  const handleClick = () => setSelectedDate(today);

  return (
    <button
      className="flex size-14 flex-col items-start rounded-lg border"
      onClick={handleClick}
    >
      <p className="flex h-6 w-full items-center justify-center bg-blue-600 text-xs font-semibold text-white">
        {formatDate(today, "MMM").toUpperCase()}
      </p>
      <p className="flex w-full items-center justify-center text-lg font-bold">
        {today.getDate()}
      </p>
    </button>
  );
}

================
File: components/month-view/calendar-month-view.tsx
================
import { useMemo } from "react";
import { useCalendar } from "../../contexts/calendar-context";
import { DayCell } from "./day-cell";
import { getCalendarCells, calculateMonthEventPositions } from "../../helpers";

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

interface IProps {
  singleDayEvents: IEvent[];
  multiDayEvents: IEvent[];
}

const WEEK_DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

export function CalendarMonthView({ singleDayEvents, multiDayEvents }: IProps) {
  const { selectedDate } = useCalendar();
  const allEvents = [...multiDayEvents, ...singleDayEvents];
  const cells = useMemo(() => getCalendarCells(selectedDate), [selectedDate]);
  const eventPositions = useMemo(
    () => calculateMonthEventPositions(multiDayEvents, singleDayEvents, selectedDate),
    [multiDayEvents, singleDayEvents, selectedDate]
  );

  return (
    <div>
      <div className="grid grid-cols-7 divide-x">
        {WEEK_DAYS.map((day) => (
          <div key={day} className="flex items-center justify-center py-2">
            <span className="text-xs font-medium text-gray-500">{day}</span>
          </div>
        ))}
      </div>
      <div className="grid grid-cols-7 overflow-hidden">
        {cells.map((cell) => (
          <DayCell
            key={cell.date.toISOString()}
            cell={cell}
            events={allEvents}
            eventPositions={eventPositions}
          />
        ))}
      </div>
    </div>
  );
}

================
File: components/month-view/day-cell.tsx
================
import { useMemo } from "react";
import { isToday, startOfDay } from "date-fns";
import { EventBullet } from "./event-bullet";
import { DroppableDayCell } from "../dnd/droppable-day-cell";
import { MonthEventBadge } from "./month-event-badge";
import { getMonthCellEvents } from "../../helpers";

interface ICalendarCell {
  day: number;
  currentMonth: boolean;
  date: Date;
}

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

interface IProps {
  cell: ICalendarCell;
  events: IEvent[];
  eventPositions: Record<string, number>;
}

const MAX_VISIBLE_EVENTS = 3;

export function DayCell({ cell, events, eventPositions }: IProps) {
  const { day, currentMonth, date } = cell;
  const cellEvents = useMemo(
    () => getMonthCellEvents(date, events, eventPositions),
    [date, events, eventPositions]
  );
  const isSunday = date.getDay() === 0;

  return (
    <DroppableDayCell cell={cell}>
      <div
        className={`flex h-full flex-col gap-1 border-l border-t py-1.5 lg:py-2 ${
          isSunday ? "border-l-0" : ""
        }`}
      >
        <span
          className={`h-6 px-1 text-xs font-semibold lg:px-2 ${
            !currentMonth ? "opacity-20" : ""
          } ${
            isToday(date)
              ? "flex w-6 translate-x-1 items-center justify-center rounded-full bg-blue-600 text-white px-0 font-bold"
              : ""
          }`}
        >
          {day}
        </span>
        <div
          className={`flex h-6 gap-1 px-2 lg:h-[94px] lg:flex-col lg:gap-2 lg:px-0 ${
            !currentMonth ? "opacity-50" : ""
          }`}
        >
          {[0, 1, 2].map((position) => {
            const event = cellEvents.find((e) => e.position === position);
            const eventKey = event
              ? `event-${event.id}-${position}`
              : `empty-${position}`;
            return (
              <div key={eventKey} className="lg:flex-1">
                {event && (
                  <>
                    <EventBullet className="lg:hidden" color={event.color} />
                    <MonthEventBadge
                      className="hidden lg:flex"
                      event={event}
                      cellDate={startOfDay(date)}
                    />
                  </>
                )}
              </div>
            );
          })}
        </div>
        {cellEvents.length > MAX_VISIBLE_EVENTS && (
          <p
            className={`h-4.5 px-1.5 text-xs font-semibold text-gray-500 ${
              !currentMonth ? "opacity-50" : ""
            }`}
          >
            <span className="sm:hidden">
              +{cellEvents.length - MAX_VISIBLE_EVENTS}
            </span>
            <span className="hidden sm:inline">
              {" "}
              {cellEvents.length - MAX_VISIBLE_EVENTS} more...
            </span>
          </p>
        )}
      </div>
    </DroppableDayCell>
  );
}

================
File: components/month-view/event-bullet.tsx
================
interface IProps {
  color: string;
  className?: string;
}

export function EventBullet({ color, className }: IProps) {
  const colorClasses: Record<string, string> = {
    blue: "bg-blue-600",
    green: "bg-green-600",
    red: "bg-red-600",
    yellow: "bg-yellow-600",
    purple: "bg-purple-600",
    orange: "bg-orange-600",
    gray: "bg-gray-600",
  };
  return (
    <div
      className={`size-2 rounded-full ${colorClasses[color] || "bg-blue-600"} ${
        className || ""
      }`}
    />
  );
}

================
File: components/month-view/month-event-badge.tsx
================
import { format, isSameDay, parseISO, startOfDay, endOfDay } from "date-fns";
import { DraggableEvent } from "../dnd/draggable-event";
import { EventDetailsDialog } from "../dialogs/event-details-dialog";

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

interface IProps {
  event: IEvent;
  cellDate: Date;
  className?: string;
  position?: "first" | "middle" | "last" | "none";
}

export function MonthEventBadge({
  event,
  cellDate,
  className,
  position: propPosition,
}: IProps) {
  const itemStart = startOfDay(parseISO(event.startDate));
  const itemEnd = endOfDay(parseISO(event.endDate));

  if (cellDate < itemStart || cellDate > itemEnd) return null;

  const position =
    propPosition ||
    (isSameDay(itemStart, itemEnd)
      ? "none"
      : isSameDay(cellDate, itemStart)
      ? "first"
      : isSameDay(cellDate, itemEnd)
      ? "last"
      : "middle");

  const colorClasses: Record<string, string> = {
    blue: "border-blue-200 bg-blue-50 text-blue-700",
    green: "border-green-200 bg-green-50 text-green-700",
    red: "border-red-200 bg-red-50 text-red-700",
    yellow: "border-yellow-200 bg-yellow-50 text-yellow-700",
    purple: "border-purple-200 bg-purple-50 text-purple-700",
    orange: "border-orange-200 bg-orange-50 text-orange-700",
    gray: "border-gray-200 bg-gray-50 text-gray-900",
  };

  const positionClasses: Record<string, string> = {
    first:
      "relative z-10 mr-0 w-[calc(100%_-_3px)] rounded-r-none border-r-0",
    middle: "relative z-10 mx-0 w-[calc(100%_+_1px)] rounded-none border-x-0",
    last: "ml-0 rounded-l-none border-l-0",
    none: "",
  };

  const eventBadgeClasses = `mx-1 flex h-6.5 items-center justify-between gap-1.5 truncate whitespace-nowrap rounded-md border px-2 text-xs ${
    colorClasses[event.color] || "border-blue-200 bg-blue-50 text-blue-700"
  } ${positionClasses[position] || ""} ${className || ""}`;

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      if (e.currentTarget instanceof HTMLElement) e.currentTarget.click();
    }
  };

  const renderBadgeText = ["first", "none"].includes(position);

  return (
    <DraggableEvent event={event}>
      <EventDetailsDialog event={event}>
        <div
          role="button"
          tabIndex={0}
          className={eventBadgeClasses}
          onKeyDown={handleKeyDown}
        >
          <div className="flex items-center gap-1.5 truncate">
            {renderBadgeText && (
              <p className="flex-1 truncate font-semibold">{event.title}</p>
            )}
          </div>
          {renderBadgeText && (
            <span>{format(new Date(event.startDate), "h:mm a")}</span>
          )}
        </div>
      </EventDetailsDialog>
    </DraggableEvent>
  );
}

================
File: components/client-container.tsx
================
"use client";

import { useMemo } from "react";
import { isSameDay, parseISO } from "date-fns";
import { useCalendar } from "../contexts/calendar-context";
import { DndProviderWrapper } from "./dnd/dnd-provider";
import { CalendarHeader } from "./header/calendar-header";
import { CalendarMonthView } from "./month-view/calendar-month-view";

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

export function ClientContainer() {
  const { events } = useCalendar();
  const filteredEvents = useMemo(() => events || [], [events]);
  const singleDayEvents = filteredEvents.filter((event) => {
    const startDate = parseISO(event.startDate);
    const endDate = parseISO(event.endDate);
    return isSameDay(startDate, endDate);
  });
  const multiDayEvents = filteredEvents.filter((event) => {
    const startDate = parseISO(event.startDate);
    const endDate = parseISO(event.endDate);
    return !isSameDay(startDate, endDate);
  });

  return (
    <div className="rounded-xl border overflow-hidden">
      <CalendarHeader view="month" events={filteredEvents} />
      <DndProviderWrapper>
        <CalendarMonthView
          singleDayEvents={singleDayEvents}
          multiDayEvents={multiDayEvents}
        />
      </DndProviderWrapper>
    </div>
  );
}

================
File: contexts/calendar-context.tsx
================
"use client";

import { createContext, useContext, useState } from "react";

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

interface IUser {
  id: string;
  name: string;
}

interface ICalendarContext {
  selectedDate: Date;
  setSelectedDate: (date: Date) => void;
  events: IEvent[];
  setEvents: (events: IEvent[]) => void;
  users: IUser[];
  addEvent: (event: IEvent) => void;
  updateEvent: (event: IEvent) => void;
}

const CalendarContext = createContext<ICalendarContext | undefined>(undefined);

export function CalendarProvider({
  children,
  users,
  events: initialEvents,
}: {
  children: React.ReactNode;
  users: IUser[];
  events: IEvent[];
}) {
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [events, setEvents] = useState<IEvent[]>(initialEvents);

  const addEvent = (event: IEvent) => {
    setEvents((prev) => [...prev, event]);
    // TODO: Call API to add event
  };

  const updateEvent = (event: IEvent) => {
    setEvents((prev) =>
      prev.map((e) => (e.id === event.id ? event : e))
    );
    // TODO: Call API to update event
  };

  return (
    <CalendarContext.Provider
      value={{
        selectedDate,
        setSelectedDate,
        events,
        setEvents,
        users,
        addEvent,
        updateEvent,
      }}
    >
      {children}
    </CalendarContext.Provider>
  );
}

export function useCalendar(): ICalendarContext {
  const context = useContext(CalendarContext);
  if (!context) throw new Error("useCalendar must be used within a CalendarProvider.");
  return context;
}

================
File: helpers.ts
================
import {
  startOfMonth,
  endOfMonth,
  format,
  parseISO,
  differenceInDays,
  eachDayOfInterval,
  startOfDay,
  isSameDay,
  isSameMonth,
  addMonths,
  subMonths,
} from "date-fns";

interface IEvent {
  id: string | number;
  startDate: string;
  endDate: string;
  title: string;
  color: string;
  description?: string;
  user?: { id: string; name: string };
}

interface ICalendarCell {
  day: number;
  currentMonth: boolean;
  date: Date;
}

export function rangeText(view: "month", date: Date) {
  const start = startOfMonth(date);
  const end = endOfMonth(date);
  return `${format(start, "MMM d, yyyy")} - ${format(end, "MMM d, yyyy")}`;
}

export function navigateDate(date: Date, view: "month", direction: "previous" | "next"): Date {
  return direction === "next" ? addMonths(date, 1) : subMonths(date, 1);
}

export function getEventsCount(events: IEvent[], date: Date, view: "month"): number {
  return events.filter((event) => isSameMonth(new Date(event.startDate), date)).length;
}

export function getCalendarCells(selectedDate: Date): ICalendarCell[] {
  const currentYear = selectedDate.getFullYear();
  const currentMonth = selectedDate.getMonth();
  const getDaysInMonth = (year: number, month: number) =>
    new Date(year, month + 1, 0).getDate();
  const getFirstDayOfMonth = (year: number, month: number) =>
    new Date(year, month, 1).getDay();
  const daysInMonth = getDaysInMonth(currentYear, currentMonth);
  const firstDayOfMonth = getFirstDayOfMonth(currentYear, currentMonth);
  const daysInPrevMonth = getDaysInMonth(currentYear, currentMonth - 1);
  const totalDays = firstDayOfMonth + daysInMonth;

  const prevMonthCells = Array.from({ length: firstDayOfMonth }, (_, i) => ({
    day: daysInPrevMonth - firstDayOfMonth + i + 1,
    currentMonth: false,
    date: new Date(
      currentYear,
      currentMonth - 1,
      daysInPrevMonth - firstDayOfMonth + i + 1
    ),
  }));
  const currentMonthCells = Array.from({ length: daysInMonth }, (_, i) => ({
    day: i + 1,
    currentMonth: true,
    date: new Date(currentYear, currentMonth, i + 1),
  }));
  const nextMonthCells = Array.from(
    { length: (7 - (totalDays % 7)) % 7 },
    (_, i) => ({
      day: i + 1,
      currentMonth: false,
      date: new Date(currentYear, currentMonth + 1, i + 1),
    })
  );

  return [...prevMonthCells, ...currentMonthCells, ...nextMonthCells];
}

export function calculateMonthEventPositions(
  multiDayEvents: IEvent[],
  singleDayEvents: IEvent[],
  selectedDate: Date
) {
  const monthStart = startOfMonth(selectedDate);
  const monthEnd = endOfMonth(selectedDate);
  const eventPositions: { [key: string]: number } = {};
  const occupiedPositions: { [key: string]: boolean[] } = {};

  eachDayOfInterval({ start: monthStart, end: monthEnd }).forEach((day) => {
    occupiedPositions[day.toISOString()] = [false, false, false];
  });

  const sortedEvents = [
    ...multiDayEvents.sort((a, b) => {
      const aDuration = differenceInDays(
        parseISO(a.endDate),
        parseISO(a.startDate)
      );
      const bDuration = differenceInDays(
        parseISO(b.endDate),
        parseISO(b.startDate)
      );
      return (
        bDuration - aDuration ||
        parseISO(a.startDate).getTime() - parseISO(b.startDate).getTime()
      );
    }),
    ...singleDayEvents.sort((a, b) =>
      parseISO(a.startDate).getTime() - parseISO(b.startDate).getTime()
    ),
  ];

  sortedEvents.forEach((event) => {
    const eventStart = parseISO(event.startDate);
    const eventEnd = parseISO(event.endDate);
    const eventDays = eachDayOfInterval({
      start: eventStart < monthStart ? monthStart : eventStart,
      end: eventEnd > monthEnd ? monthEnd : eventEnd,
    });

    let position = -1;
    for (let i = 0; i < 3; i++) {
      if (
        eventDays.every((day) => {
          const dayPositions = occupiedPositions[startOfDay(day).toISOString()];
          return dayPositions && !dayPositions[i];
        })
      ) {
        position = i;
        break;
      }
    }

    if (position !== -1) {
      eventDays.forEach((day) => {
        const dayKey = startOfDay(day).toISOString();
        occupiedPositions[dayKey][position] = true;
      });
      eventPositions[event.id] = position;
    }
  });

  return eventPositions;
}

export function getMonthCellEvents(
  date: Date,
  events: IEvent[],
  eventPositions: Record<string, number>
) {
  const eventsForDate = events.filter((event) => {
    const eventStart = parseISO(event.startDate);
    const eventEnd = parseISO(event.endDate);
    return (
      (date >= eventStart && date <= eventEnd) ||
      isSameDay(date, eventStart) ||
      isSameDay(date, eventEnd)
    );
  });

  return eventsForDate
    .map((event) => ({
      ...event,
      position: eventPositions[event.id] ?? -1,
      isMultiDay: event.startDate !== event.endDate,
    }))
    .sort((a, b) => {
      if (a.isMultiDay && !b.isMultiDay) return -1;
      if (!a.isMultiDay && b.isMultiDay) return 1;
      return a.position - b.position;
    });
}

================
File: layout.tsx
================
import { CalendarProvider } from "./contexts/calendar-context";
import { SessionProvider } from "next-auth/react";
import { SidebarInset, SidebarProvider, SidebarTrigger } from "@/components/ui/sidebar";
import { AppSidebar } from "@/components/app-sidebar";
import Script from "next/script";
import { auth } from "@/app/(auth)/auth";
import { cookies } from "next/headers";
import { Separator } from "@/components/ui/separator";

export default async function Layout({ children }: { children: React.ReactNode }) {
  const [session, cookieStore] = await Promise.all([auth(), cookies()]);
  const isCollapsed = cookieStore.get('sidebar:state')?.value !== 'true';

  return (
    <SessionProvider session={session}>
      <Script
        src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"
        strategy="beforeInteractive"
      />
      <SidebarProvider defaultOpen={!isCollapsed}>
        <AppSidebar user={session?.user} />
        <SidebarInset>
          <>
            <header className="flex h-16 shrink-0 items-center gap-2 border-b pr-10">
              <div className="flex items-center gap-2 px-3">
                <SidebarTrigger />
                <Separator orientation="vertical" className="mr-2 h-4" />
                <h4>Schedule</h4>
              </div>
            </header>
            <div className="flex flex-col gap-4 px-8 py-4">
              {children}
            </div>
          </>
        </SidebarInset>
      </SidebarProvider>
    </SessionProvider>
  );
}

================
File: page.tsx
================
import { ClientContainer } from "./components/client-container";
import { CalendarProvider } from "./contexts/calendar-context";

// Replace with your API call
async function fetchEvents() {
  return []; // Example: await fetch('/api/events').then(res => res.json());
}

async function fetchUsers() {
  return []; // Example: await fetch('/api/users').then(res => res.json());
}

export default async function Page() {
  const [events, users] = await Promise.all([fetchEvents(), fetchUsers()]);
  return (
    <CalendarProvider users={users} events={events}>
      <ClientContainer />
    </CalendarProvider>
  );
}

================
File: types.ts
================
export type TCalendarView = "month";
export type TEventColor =
  | "blue"
  | "green"
  | "red"
  | "yellow"
  | "purple"
  | "orange"
  | "gray";



================================================================
End of Codebase
================================================================
